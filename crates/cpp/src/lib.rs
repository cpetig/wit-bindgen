use heck::{ToPascalCase, ToShoutySnakeCase, ToSnakeCase, ToUpperCamelCase};
use std::{collections::HashMap, fmt::Write};
use wit_bindgen_core::{
    uwrite, uwriteln,
    wit_parser::{
        Function, InterfaceId, Resolve, TypeDefKind, TypeId, TypeOwner, WorldId, WorldKey,
    },
    Files, InterfaceGenerator, Source, WorldGenerator,
};

mod wamr;

pub const RESOURCE_BASE_CLASS_NAME: &str = "ResourceBase";
pub const OWNED_CLASS_NAME: &str = "Owned";

// follows https://google.github.io/styleguide/cppguide.html

#[derive(Default)]
struct Includes {
    needs_vector: bool,
    needs_expected: bool,
    needs_string: bool,
    needs_string_view: bool,
    needs_optional: bool,
    needs_cstring: bool,
    needs_guest_alloc: bool,
    needs_resources: bool,
}

#[derive(Clone)]
struct HostFunction {
    wasm_name: String,
    wamr_signature: String,
    host_name: String,
}

#[derive(Default)]
struct Cpp {
    opts: Opts,
    c_src: Source,
    h_src: Source,
    dependencies: Includes,
    includes: Vec<String>,
    host_functions: HashMap<String, Vec<HostFunction>>,
    world: String,
}

#[derive(Default, Debug, Clone)]
#[cfg_attr(feature = "clap", derive(clap::Args))]
pub struct Opts {
    /// Generate host bindings
    #[cfg_attr(feature = "clap", arg(long, default_value_t = bool::default()))]
    pub host: bool,
    /// Generate code for directly linking to guest code
    #[cfg_attr(feature = "clap", arg(long, default_value_t = bool::default()))]
    pub short_cut: bool,
}

impl Opts {
    pub fn build(self) -> Box<dyn WorldGenerator> {
        let mut r = Cpp::new();
        r.opts = self;
        Box::new(r)
    }
}

impl Cpp {
    fn new() -> Cpp {
        Cpp::default()
    }

    fn include(&mut self, s: &str) {
        self.includes.push(s.to_string());
    }

    fn interface<'a>(
        &'a mut self,
        resolve: &'a Resolve,
        name: &'a Option<&'a WorldKey>,
        in_import: bool,
    ) -> CppInterfaceGenerator<'a> {
        CppInterfaceGenerator {
            src: Source::default(),
            gen: self,
            resolve,
            interface: None,
            name,
            // public_anonymous_types: BTreeSet::new(),
            in_import,
            // export_funcs: Vec::new(),
        }
    }
}

impl WorldGenerator for Cpp {
    fn preprocess(&mut self, resolve: &Resolve, world: WorldId) {
        let name = &resolve.worlds[world].name;
        self.world = name.to_string();
        //        self.sizes.fill(resolve);
    }

    fn import_interface(
        &mut self,
        resolve: &Resolve,
        name: &WorldKey,
        id: InterfaceId,
        _files: &mut Files,
    ) {
        let binding = Some(name);
        let mut gen = self.interface(resolve, &binding, true);
        gen.interface = Some(id);
        // if self.gen.interfaces_with_types_printed.insert(id) {
        gen.types(id);
        // }

        for (_name, _func) in resolve.interfaces[id].functions.iter() {
            // gen.import(resolve, func);
        }
        // gen.finish();
    }

    fn export_interface(
        &mut self,
        _resolve: &Resolve,
        _name: &WorldKey,
        _iface: InterfaceId,
        _files: &mut Files,
    ) -> anyhow::Result<()> {
        todo!()
    }

    fn import_funcs(
        &mut self,
        _resolve: &Resolve,
        _world: WorldId,
        _funcs: &[(&str, &Function)],
        _files: &mut Files,
    ) {
        todo!()
    }

    fn export_funcs(
        &mut self,
        _resolve: &Resolve,
        _world: WorldId,
        _funcs: &[(&str, &Function)],
        _files: &mut Files,
    ) -> anyhow::Result<()> {
        todo!()
    }

    fn import_types(
        &mut self,
        _resolve: &Resolve,
        _world: WorldId,
        _types: &[(&str, TypeId)],
        _files: &mut Files,
    ) {
        todo!()
    }

    fn finish(&mut self, resolve: &Resolve, world_id: WorldId, files: &mut Files) {
        let world = &resolve.worlds[world_id];
        let snake = world.name.to_snake_case();

        let mut h_str = Source::default();
        let mut c_str = Source::default();
        let mut h_namespace = Vec::new();

        let version = env!("CARGO_PKG_VERSION");
        uwriteln!(
            h_str,
            "// Generated by `wit-bindgen` {version}. DO NOT EDIT!"
        );

        if !self.opts.host {
            uwrite!(
                h_str,
                "#ifndef __CPP_GUEST_BINDINGS_{0}_H
                #define __CPP_GUEST_BINDINGS_{0}_H\n",
                world.name.to_shouty_snake_case(),
            );
        } else {
            uwrite!(
                h_str,
                "#ifndef __CPP_HOST_BINDINGS_{0}_H
                #define __CPP_HOST_BINDINGS_{0}_H\n",
                world.name.to_shouty_snake_case(),
            );
        }
        self.include("<cstdint>");
        if self.dependencies.needs_string {
            self.include("<string>");
        }
        if self.dependencies.needs_string_view {
            self.include("<string_view>");
        }
        if self.dependencies.needs_vector {
            self.include("<vector>");
        }
        if self.dependencies.needs_expected {
            self.include("<expected>");
        }
        if self.dependencies.needs_optional {
            self.include("<optional>");
        }
        if self.dependencies.needs_cstring {
            self.include("<cstring>");
        }
        if !self.opts.host && self.dependencies.needs_resources {
            self.include("<cassert>");
        }

        for include in self.includes.iter() {
            uwriteln!(h_str, "#include {include}");
        }

        uwriteln!(
            c_str,
            "// Generated by `wit-bindgen` {version}. DO NOT EDIT!"
        );
        if !self.opts.host {
            uwriteln!(c_str, "#include \"{snake}_cpp.h\"");
        } else {
            uwriteln!(c_str, "#include \"{snake}_cpp_host.h\"");
            if !self.opts.short_cut {
                uwriteln!(
                    c_str,
                    "#include <wasm_export.h> // wasm-micro-runtime header"
                );

                if c_str.len() > 0 {
                    c_str.push_str("\n");
                }
                if self.dependencies.needs_guest_alloc {
                    uwriteln!(
                        c_str,
                        "int32_t guest_alloc(wasm_exec_env_t exec_env, uint32_t size);"
                    );
                }
            }
        }

        if self.dependencies.needs_resources {
            let namespace = namespace(resolve, TypeOwner::World(world_id));
            change_namespace(&mut h_namespace, &namespace, &mut h_str);
            if self.opts.host {
                uwriteln!(
                    h_str,
                    "class {RESOURCE_BASE_CLASS_NAME} {{
                            public:
                            int32_t id;
                            virtual ~{RESOURCE_BASE_CLASS_NAME}();
                            {RESOURCE_BASE_CLASS_NAME}();
                            static {RESOURCE_BASE_CLASS_NAME}* lookup_resource(int32_t id);
                        }}; 
                        template <typename T> struct {OWNED_CLASS_NAME} {{
                            T *ptr;
                        }};"
                );
            } else {
                // somehow spaces get removed, newlines remain (problem occurs before const&)
                uwriteln!(
                    h_str,
                    "class {RESOURCE_BASE_CLASS_NAME} {{
                            static const int32_t invalid = -1;
                            protected:
                            int32_t handle;
                            public:
                            {RESOURCE_BASE_CLASS_NAME}(int32_t h=invalid) : handle(h) {{}}
                            {RESOURCE_BASE_CLASS_NAME}({RESOURCE_BASE_CLASS_NAME}&&r) 
                                : handle(r.handle) {{ 
                                    r.handle=invalid; 
                            }}
                            {RESOURCE_BASE_CLASS_NAME}({RESOURCE_BASE_CLASS_NAME} 
                                const&) = delete;
                            void set_handle(int32_t h) {{ handle=h; }}
                            int32_t get_handle() const {{ return handle; }}
                            int32_t into_raw() {{
                                int32_t h= handle;
                                handle= invalid;
                                return h;
                            }}
                            {RESOURCE_BASE_CLASS_NAME}& operator=({RESOURCE_BASE_CLASS_NAME}&&r) {{
                                assert(handle<0);
                                handle= r.handle;
                                r.handle= invalid;
                                return *this;
                            }}
                            {RESOURCE_BASE_CLASS_NAME}& operator=({RESOURCE_BASE_CLASS_NAME} 
                                const&r) = delete;
                            }};"
                );
            }
        }
        change_namespace(&mut h_namespace, &Vec::default(), &mut h_str);

        c_str.push_str(&self.c_src);
        h_str.push_str(&self.h_src);
        // c_str.push_str(&self.src.c_fns);

        // if self.src.h_defs.len() > 0 {
        //     h_str.push_str(&self.src.h_defs);
        // }

        // h_str.push_str(&self.src.h_fns);

        uwriteln!(c_str, "\n// Component Adapters");

        // c_str.push_str(&self.src.c_adapters);

        if !self.opts.short_cut && self.opts.host {
            uwriteln!(
                h_str,
                "extern \"C\" void register_{}();",
                world.name.to_snake_case()
            );
            uwriteln!(c_str, "void register_{}() {{", world.name.to_snake_case());
            for i in self.host_functions.iter() {
                uwriteln!(
                    c_str,
                    "  static NativeSymbol {}_funs[] = {{",
                    i.0.replace(":", "_").to_snake_case()
                );
                for f in i.1.iter() {
                    uwriteln!(
                        c_str,
                        "    {{ \"{}\", (void*){}, \"{}\", nullptr }},",
                        f.wasm_name,
                        f.host_name,
                        f.wamr_signature
                    );
                }
                uwriteln!(c_str, "  }};");
            }
            for i in self.host_functions.iter() {
                uwriteln!(c_str, "  wasm_runtime_register_natives(\"{}\", {1}_funs, sizeof({1}_funs)/sizeof(NativeSymbol));", i.0, i.0.replace(":", "_").to_snake_case());
            }
            uwriteln!(c_str, "}}");
        }

        uwriteln!(
            h_str,
            "
            #endif"
        );

        if !self.opts.host {
            files.push(&format!("{snake}.cpp"), c_str.as_bytes());
            files.push(&format!("{snake}_cpp.h"), h_str.as_bytes());
        } else {
            files.push(&format!("{snake}_host.cpp"), c_str.as_bytes());
            files.push(&format!("{snake}_cpp_host.h"), h_str.as_bytes());
        }
    }
}

// determine namespace
fn namespace(resolve: &Resolve, owner: TypeOwner) -> Vec<String> {
    let mut result = Vec::default();
    match owner {
        TypeOwner::World(w) => result.push(resolve.worlds[w].name.to_snake_case()),
        TypeOwner::Interface(i) => {
            let iface = &resolve.interfaces[i];
            let pkg = &resolve.packages[iface.package.unwrap()];
            result.push(pkg.name.namespace.to_snake_case());
            result.push(pkg.name.name.to_snake_case());
            if let Some(name) = &iface.name {
                result.push(name.to_snake_case());
            }
        }
        TypeOwner::None => (),
    }
    result
}

fn change_namespace(current: &mut Vec<String>, target: &Vec<String>, output: &mut Source) {
    let mut same = 0;
    // itertools::fold_while?
    for (a, b) in current.iter().zip(target.iter()) {
        if a == b {
            same += 1;
        } else {
            break;
        }
    }
    for _i in same..current.len() {
        uwrite!(output, "}}");
    }
    current.truncate(same);
    for i in target.iter().skip(same) {
        uwrite!(output, "namespace {} {{", i);
        current.push(i.clone());
    }
}

struct CppInterfaceGenerator<'a> {
    src: Source,
    gen: &'a mut Cpp,
    resolve: &'a Resolve,
    interface: Option<InterfaceId>,
    name: &'a Option<&'a WorldKey>,
    //    public_anonymous_types: BTreeSet<TypeId>,
    in_import: bool,
    //    export_funcs: Vec<(String, String)>,
}

impl CppInterfaceGenerator<'_> {
    fn types(&mut self, iface: InterfaceId) {
        let iface = &self.resolve().interfaces[iface];
        for (name, id) in iface.types.iter() {
            self.define_type(name, *id);
        }
    }

    fn define_type(&mut self, name: &str, id: TypeId) {
        let ty = &self.resolve().types[id];
        match &ty.kind {
            TypeDefKind::Record(record) => self.type_record(id, name, record, &ty.docs),
            TypeDefKind::Resource => self.type_resource(id, name, &ty.docs),
            TypeDefKind::Flags(flags) => self.type_flags(id, name, flags, &ty.docs),
            TypeDefKind::Tuple(tuple) => self.type_tuple(id, name, tuple, &ty.docs),
            TypeDefKind::Enum(enum_) => self.type_enum(id, name, enum_, &ty.docs),
            TypeDefKind::Variant(variant) => self.type_variant(id, name, variant, &ty.docs),
            TypeDefKind::Option(t) => self.type_option(id, name, t, &ty.docs),
            TypeDefKind::Result(r) => self.type_result(id, name, r, &ty.docs),
            TypeDefKind::List(t) => self.type_list(id, name, t, &ty.docs),
            TypeDefKind::Type(t) => self.type_alias(id, name, t, &ty.docs),
            TypeDefKind::Future(_) => todo!("generate for future"),
            TypeDefKind::Stream(_) => todo!("generate for stream"),
            TypeDefKind::Handle(_) => todo!("generate for handle"),
            TypeDefKind::Unknown => unreachable!(),
        }
    }
}

impl<'a> wit_bindgen_core::InterfaceGenerator<'a> for CppInterfaceGenerator<'a> {
    fn resolve(&self) -> &'a Resolve {
        self.resolve
    }

    fn type_record(
        &mut self,
        _id: TypeId,
        _name: &str,
        _record: &wit_bindgen_core::wit_parser::Record,
        _docs: &wit_bindgen_core::wit_parser::Docs,
    ) {
        todo!()
    }

    fn type_resource(&mut self, id: TypeId, name: &str, docs: &wit_bindgen_core::wit_parser::Docs) {
        let type_ = &self.resolve.types[id];
        if let TypeOwner::Interface(intf) = type_.owner {
            let mut world_name = self.gen.world.to_snake_case();
            world_name.push_str("::");
            let funcs = self.resolve.interfaces[intf].functions.values();

            self.gen.dependencies.needs_resources = true;
            let pascal = name.to_upper_camel_case();

            // if self.in_import {

            // } else {

            // }

            let derive = format!(" : public {world_name}{RESOURCE_BASE_CLASS_NAME}");
            uwriteln!(self.gen.h_src, "class {pascal}{derive} {{\n");
            if !self.gen.opts.host {
                //gen.src.h_defs("  int32_t handle;\nbool owned;\n");
            } else {
                uwriteln!(
                    self.gen.h_src,
                    "  // private implementation data\n  struct pImpl;\n  pImpl * p_impl;\n"
                );
            }
            uwriteln!(self.gen.h_src, "public:\n");
            // destructor
            uwriteln!(self.gen.h_src, "~{pascal}();\n");
            for func in funcs {
                // self.gen.import(Some(name), func);
            }

            if !self.gen.opts.host {
                // consuming constructor from handle (bindings)
                uwriteln!(
                    self.gen.h_src,
                    "{pascal}({world_name}{RESOURCE_BASE_CLASS_NAME}&&);\n"
                );
                uwriteln!(self.gen.h_src, "{pascal}({pascal}&&) = default;\n");
            }
            uwriteln!(self.gen.h_src, "}};\n");

            let iface = &self.resolve.interfaces[intf];
            let pkg = &self.resolve.packages[iface.package.unwrap()];
            let mut interface_name = pkg.name.namespace.to_snake_case();
            interface_name.push_str("_");
            interface_name.push_str(&pkg.name.name.to_snake_case());
            interface_name.push_str("_");
            interface_name.push_str(&iface.name.as_ref().unwrap().to_snake_case());
            let resource = self.resolve.types[id].name.as_deref().unwrap();
            let resource_snake = resource.to_snake_case();
            let host_name = format!("host_{interface_name}_resource_drop_{resource_snake}");
            let wasm_name = format!("[resource-drop]{resource}");
            uwriteln!(self.gen.c_src, "static void {host_name}(wasm_exec_env_t exec_env, int32_t self) {{\n  delete {world_name}{RESOURCE_BASE_CLASS_NAME}::lookup_resource(self);\n}}\n", );
            // let remember = HostFunction {
            //     wasm_name,
            //     wamr_signature: "(i)".into(),
            //     host_name,
            // };
            // let module_name = self.resolve.name_world_key(name);
            // self.gen
            //     .host_functions
            //     .entry(module_name)
            //     .and_modify(|v| v.push(remember.clone()))
            //     .or_insert(vec![remember]);

            // let entry = self
            //     .gen
            //     .resources
            //     .entry(dealias(self.resolve, id))
            //     .or_default();
            // if !self.in_import {
            //     entry.direction = Direction::Export;
            // }
            // entry.docs = docs.clone();
        }
    }

    fn type_flags(
        &mut self,
        _id: TypeId,
        _name: &str,
        _flags: &wit_bindgen_core::wit_parser::Flags,
        _docs: &wit_bindgen_core::wit_parser::Docs,
    ) {
        todo!()
    }

    fn type_tuple(
        &mut self,
        _id: TypeId,
        _name: &str,
        _flags: &wit_bindgen_core::wit_parser::Tuple,
        _docs: &wit_bindgen_core::wit_parser::Docs,
    ) {
        todo!()
    }

    fn type_variant(
        &mut self,
        _id: TypeId,
        _name: &str,
        _variant: &wit_bindgen_core::wit_parser::Variant,
        _docs: &wit_bindgen_core::wit_parser::Docs,
    ) {
        todo!()
    }

    fn type_option(
        &mut self,
        _id: TypeId,
        _name: &str,
        _payload: &wit_bindgen_core::wit_parser::Type,
        _docs: &wit_bindgen_core::wit_parser::Docs,
    ) {
        todo!()
    }

    fn type_result(
        &mut self,
        _id: TypeId,
        _name: &str,
        _result: &wit_bindgen_core::wit_parser::Result_,
        _docs: &wit_bindgen_core::wit_parser::Docs,
    ) {
        todo!()
    }

    fn type_enum(
        &mut self,
        _id: TypeId,
        _name: &str,
        _enum_: &wit_bindgen_core::wit_parser::Enum,
        _docs: &wit_bindgen_core::wit_parser::Docs,
    ) {
        todo!()
    }

    fn type_alias(
        &mut self,
        _id: TypeId,
        _name: &str,
        _ty: &wit_bindgen_core::wit_parser::Type,
        _docs: &wit_bindgen_core::wit_parser::Docs,
    ) {
        todo!()
    }

    fn type_list(
        &mut self,
        _id: TypeId,
        _name: &str,
        _ty: &wit_bindgen_core::wit_parser::Type,
        _docs: &wit_bindgen_core::wit_parser::Docs,
    ) {
        todo!()
    }

    fn type_builtin(
        &mut self,
        _id: TypeId,
        _name: &str,
        _ty: &wit_bindgen_core::wit_parser::Type,
        _docs: &wit_bindgen_core::wit_parser::Docs,
    ) {
        todo!()
    }
}
